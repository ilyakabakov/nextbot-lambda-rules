---
description: Правила генерации скрипта python-функции для NextBot
globs: **/*.py
alwaysApply: false
---
# Важно:

## При генерации python скриптов:

### 1. Использовать только эти библиотеки, они определены в safe_globals и дополнительно импортировать их в скрипт не нужно:
```
    import json
	import requests
	import re
	import base64
	import math
	import datetime
	import time
	import random
	import decimal
	import statistics
	import urllib.parse
	import gspread
	import smtplib
	import ssl
	from email.mime.text import MIMEText
	from oauth2client.service_account import ServiceAccountCredentials
	from supabase import create_client, Client
```

### 2. Запрещено:
	- использование дандерметодов
	- использование аннотаций типов
	- декларация функций и переменных с нижним подчеркиванием вначале или в конце.
	- использование datetime.strptime("%m/%d;%Y"), это вызовет ошибку
	- создание клиента supabase как create_client(supabase_url, supabase_key)
	- декарация классов
	- спагетти-код и pyramid of doom


### 2.1 Плоская структура (обязательно):
	- **Запрещена вложенность глубже 2 уровней.** Цепочка if  else --> try --> else --> if --> else — недопустима. 
	- Если шагов много — выноси их в функции (п.8)
	- **Guard clauses:** сначала проверка аргументов/ответа; при ошибке сразу `result = {"status": "error", "message": "..."}` и дальше этот сценарий не продолжать (следующий шаг — отдельным блоком после проверки, без лишнего else)
	- **Один шаг — один плоский блок.** Схема: «сделали шаг --> если ошибка, возвращаем ошибку в result и стоп; если нет то следующий шаг» — без вложения следующего шага внутрь else предыдущего
	- Код должен читаться **сверху вниз** как последовательность шагов; не «лесенка» из отступов

### 3. Всегда проверять наличие вложенных дандерметодов из RestrictedPython(
		from RestrictedPython import compile_restricted
		from RestrictedPython.Guards import guarded_iter_unpack_sequence
		from RestrictedPython.Guards import safer_getattr
		from RestrictedPython.Eval import default_guarded_getitem
		from RestrictedPython.Eval import default_guarded_getiter
		from RestrictedPython.Guards import full_write_guard
		from RestrictedPython.PrintCollector import PrintCollector
		) при использовании разрешенных библиотек, чтобы избежать ошибки по __import__.

### 3.1 Использование конструкций try/except

- `try` должен быть **минимальным по объёму**:  
  оборачивать **только те строки**, которые реально могут выбросить исключение.  
  Большие или глубоко вложенные `try` ухудшают читаемость и сопровождение кода.

- Исключения должны быть **максимально конкретными**.  
  Использование `except Exception` допускается только как крайняя мера.

- **Читаемость важнее всего**.  
  Код должен позволять быстро понять:
  где может произойти ошибка и как она обрабатывается.

- Когда вложенные `try/except` допустимы:
  - разные уровни обрабатывают **разные классы ошибок**
  - каждый `except` имеет **чёткую и единственную ответственность**
  - отказ от вложенности делает код менее понятным или более хрупким

- Пример допустимого сценария:
  - внешний `try` — бизнес-логика
  - внутренний `try` — сетевой запрос, парсинг или работа с внешним API

- Когда это считается плохой практикой:
  - `try` внутри `try` внутри `try` без явной необходимости
  - одинаковые `except Exception` на разных уровнях
  - использование исключений для управления логикой выполнения
  - невозможно однозначно определить место возникновения ошибки

### 3.2 В скриптах не использовать распаковку возврата функции в несколько переменных в одном присваивании (например a, b = func())

### 3.3 Запрещено возвращать кортежи из функций (явные и неявные)
- `return value, None` и `return None, error_dict` — запрещены
- Функция всегда возвращает **один объект**: либо данные, либо error-словарь
- Для разграничения "успех / ошибка" используй словарь-обёртку `{"ok": True/False, ...}`:

```python
# ЗАПРЕЩЕНО
return product_id, None
return None, {"status": "error", "message": "..."}

# ПРАВИЛЬНО — обёртка с ok-флагом
return {"ok": True, "data": product_id}
return {"ok": False, "error": "сообщение об ошибке"}
```

- Проверка результата в вызывающем коде:
```python
res = some_func()
if not res["ok"]:
    result = {"status": "error", "message": res["error"]}
# дальше используем res["data"]
```

### 4. Вместо print() всегда используем debug(text)

### 5. Клиент supabase создается как обращение к supabase в safe_globals с передачей туда ссылки на бд и ключа, то есть 
	sb = supabase["create_client"](supabase_url, supabase_key)

### 6. Входящие данные определены в словаре args, если пользователь просит сгенерировать скрипт принирмающий name, phone, date значит это будут соответствующие ключи в словаре args

### 7. Константы, credentials и прочие данные окружения: выносятся всегда в начало скрипта

### 7.1 API ключи, токены и BASE_URL запросов, это константы, декларируй как константы, в словаре args их не будет. 

### 8. Допускается декларация функций(def), но только там где это действительно нужно:
	- повторяющаяся валидация
	- несколько независимых шагов
	- один и тот же код вызывается ≥2 раз
	- много конструкций if/else

### 9. Результат всегда добавляется в словарь result, пример: 
	- в случае успешного выполнения скрипта:
		```
		result = {
			"status": "success",
			"processed_data": data
		}```
	- в случае ошибки:
		```
		result = {
			"status": "error",
			"message": text_of_error
		}

		```
### 10. Соблюдать DRY и PEP8


# Пример структуры(псевдокод):
```
# === КОНСТАНТЫ (всегда в начале) ===
SUPABASE_URL, SUPABASE_KEY, MOYSKLAD_BASE_URL, MOYSKLAD_TOKEN

# === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ (одна ответственность) ===

validate_args():
    если нет args["text"]  → return {"ok": False, "error": "..."}
    если нет args["name"]  → return {"ok": False, "error": "..."}
    если нет args["phone"] → return {"ok": False, "error": "..."}
    return {"ok": True}

search_supabase(q):
    sb = supabase["create_client"](SUPABASE_URL, SUPABASE_KEY)
    попытка: rpc("search", {"q": q}).execute()
    при ошибке → return {"ok": False, "error": "..."}
    если ответ пустой / нет product_id → return {"ok": False, "error": "..."}
    return {"ok": True, "data": product_id}

create_order_moysklad(product_id, name, phone):
    headers = авторизация МойСклад
    GET организация → organization_meta
    при ошибке / нет организаций → return {"ok": False, "error": "..."}
    POST контрагент (name, phone) → agent_meta
    при ошибке → return {"ok": False, "error": "..."}
    POST заказ (organization_meta, agent_meta, позиция по product_id)
    при ошибке → return {"ok": False, "error": "..."}
    return {"ok": True, "data": order_data}

# === ГЛАВНАЯ ФУНКЦИЯ — весь основной поток здесь ===
# Использует early return как guard clause — никакого дублирования условий
def run():
    val = validate_args()
    если не val["ok"] → return {"status": "error", "message": val["error"]}

    search_res = search_supabase(args["text"])
    если не search_res["ok"] → return {"status": "error", "message": search_res["error"]}

    order_res = create_order_moysklad(search_res["data"], args["name"], args["phone"])
    если не order_res["ok"] → return {"status": "error", "message": order_res["error"]}

    return {"status": "success", "processed_data": order_res["data"]}

# === ТОЧКА ВХОДА ===
result = run()
```
